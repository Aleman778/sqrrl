
// TODO(Alexander): we only have windows support atm. later on we import the correct header
#include "ucrtwindows.h"


f32 cos(f32 num) {
    return _cos_f32(num);
}

f32 acos(f32 num) {
    return _acos_f32(num);
}

f32 sin(f32 num) {
    return _sin_f32(num);
}

f32 asin(f32 num) {
    return _asin_f32(num);
}

f32 tan(f32 num) {
    return _tan_f32(num);
}

f32 atan(f32 num) {
    return _atan_f32(num);
}

f32 sqrt(f32 num) {
    return _sqrt_f32(num);
}

f32 round(f32 num) {
    return _round_f32(num);
}

f32 floor(f32 num) {
    return _floor_f32(num);
}

f32 ceil(f32 num) {
    return _ceil_f32(num);
}

f32 abs(f32 num) {
    return _abs_f32(num);
}

s32 abs(s32 num) {
    // TODO(Alexander): we can perhaps optimize this?
    return num < 0 ? -num : num;
}

f32 random_f32() {
    return (f32) _random_s32() / (RAND_MAX + 1.0f);
}

enum Type_Kind {
    Unresolved,
    Void,
    Any,
    Type,
    Basic,
    Array,
    Struct,
    Union,
    Enum,
    Function,
    Pointer,
};

enum Basic_Type_Info {
    Bool,
    S8,
    S16,
    S32,
    S64,
    U8,
    U16,
    U32,
    U64,
    F32,
    F64,
    String,
    CString
}

struct Type_Info {
    Type_Kind kind;
    
    union {
        Basic_Type_Info Basic;
        Struct_Type_Info Struct;
        Enum_Type_Info Enum;
        Array_Type_Info Array;
    };
}

struct Struct_Field_Info {
    Type_Info* type;
    string ident;
    s64 offset;
}

struct Struct_Type_Info {
    string ident;
    []Struct_Field_Info fields;
}

struct Enum_Type_Info {
    string ident;
    Type_Info* type;
    []string names;
}

struct Array_Type_Info {
    Type_Info* elem_type;
    smm elem_size;
    smm fixed_count; // -1 => if value stores the count
}

inline Type_Info*
type_info(Type type) {
    return (Type_Info*) type;
}

#if 0
void
print_old(cstring format, ...) {
    va_list args;
    va_start(args, format);
    
    //printf("\n\ntest: %s\n\n", format);
    
    const char* format_at_prev_percent = format;
    int count_until_percent = 0;
    while (*format != '\0') {
        // TODO(Alexander): can we improve escaping % or change the template marker altogether
        //if (*format == '\\' && *(format + 1) == '%') {
        //printf("%%");
        //format += 2;
        //format_at_prev_percent = format;
        //continue;
        //}
        
        if (*format == '%') {
            if (*(format + 1) == '%') {
                printf("%%");
                format += 2;
                format_at_prev_percent = format;
                continue;
            }
            
            if (count_until_percent > 0) {
                printf("%.*s", count_until_percent, format_at_prev_percent);
                count_until_percent = 0;
            }
            
            format_at_prev_percent = format + 1;
            
            Format_Type type = (Format_Type) va_arg(args, int);
            switch (type) {
                case FormatType_bool: {
                    printf("%s", va_arg(args, bool) ? "true" : "false");
                } break;
                
                case FormatType_char: {
                    printf("%c", va_arg(args, char));
                } break;
                
                case FormatType_s8: {
                    printf("%ld", (s32) va_arg(args, s8));
                } break;
                
                case FormatType_s16: {
                    printf("%ld", (s32) va_arg(args, s16));
                } break;
                
                case FormatType_int: {
                    printf("%d", va_arg(args, int));
                } break;
                
                case FormatType_s32: {
                    printf("%ld", va_arg(args, s32));
                } break;
                
                case FormatType_uint: {
                    printf("%u", va_arg(args, uint));
                } break;
                
                case FormatType_s64: {
                    printf("%lld", va_arg(args, s64));
                } break;
                
                case FormatType_u8: {
                    printf("%c", (char) va_arg(args, u8));
                } break;
                
                case FormatType_u16: {
                    printf("%lu", (u32) va_arg(args, u16));
                } break;
                
                case FormatType_u32: {
                    printf("%lu", va_arg(args, u32));
                } break;
                
                case FormatType_u64: {
                    printf("%llu", va_arg(args, u64));
                } break;
                
                case FormatType_u64_HEX: {
                    printf("0x%llX", va_arg(args, u64));
                } break;
                
                case FormatType_smm: {
                    printf("%zd", va_arg(args, smm));
                } break;
                
                case FormatType_umm: {
                    printf("%zu", va_arg(args, umm));
                } break;
                
                case FormatType_f32: {
                    printf("%f", va_arg(args, f32));
                } break;
                
                case FormatType_f64: {
                    printf("%f", va_arg(args, f64));
                } break;
                
                case FormatType_string: {
                    string str = va_arg(args, string);
                    printf("%.*s", (int) str.count, (char*) str.data);
                } break;
                
                case FormatType_memory_string: {
                    Memory_String str = va_arg(args, Memory_String);
                    printf("%.*s", (int) memory_string_count(str), (char*) str);
                } break;
                
                case FormatType_cstring: {
                    printf("%s", va_arg(args, char*));
                } break;
                
                case FormatType_ast: {
                    print_ast(va_arg(args, Ast*), 0);
                } break;
                
                case FormatType_type: {
                    print_type(va_arg(args, Type*));
                } break;
                
                case FormatType_value: {
                    print_value(va_arg(args, Value*));
                } break;
                
                case FormatType_intermediate_code: {
                    print_intermediate_code(va_arg(args, Intermediate_Code*));
                } break;
                
                default: {
                    assert(0 && "unimplemented format type");
                } break;
            }
        } else {
            count_until_percent++;
        }
        
        format++;
    }
    
    if (count_until_percent > 0) {
        printf("%.*s", count_until_percent, format_at_prev_percent);
    }
}
#endif

void
print_newline_with_spaces(int count) {
    print("\n");
    for (int i = 0; i < count; i++) {
        print(" ");
    }
}

s64
data_to_s64(Basic_Type_Info info, void* data) {
    switch (info) {
        case Basic_Type_Info.S8: {
            return *((s8*) data);
        }
        
        case Basic_Type_Info.S16: {
            return *((s16*) data);
        }
        
        case Basic_Type_Info.S32: {
            return *((s32*) data);
        }
        
        case Basic_Type_Info.S64: {
            return *((s64*) data);
        }
    }
    
    return 0;
}

u64
data_to_u64(Basic_Type_Info info, void* data) {
    switch (info) {
        case Basic_Type_Info.U8: {
            return *((u8*) data);
        }
        
        case Basic_Type_Info.U16: {
            return *((u16*) data);
        }
        
        case Basic_Type_Info.U32: {
            return *((u32*) data);
        }
        
        case Basic_Type_Info.U64: {
            return *((u64*) data);
        }
    }
    
    return 0;
}


f64
data_to_f64(Basic_Type_Info info, void* data) {
    switch (info) {
        case Basic_Type_Info.F32: {
            return *((f32*) data);
        }
        
        case Basic_Type_Info.F64: {
            return *((f64*) data);
        }
    }
    
    return 0.0f;
}

struct Var_Args {
    []Type_Info type_info;
    u8* data;
}

void
print(string format, ...) {
    //Var_Args args = print.var_args;
    
    for (smm chr_index; chr_index < format.count; chr_index++) {
        u8 chr = format.data[chr_index];
        
    }
}

void
print_data_from_type_info(Type_Info* type, void* data, int indent=0) {
    switch (type.kind) {
        case Type_Kind.Basic: {
            switch (type.Basic) {
                case Basic_Type_Info.Bool: {
                    if (*((bool*) data)) {
                        printf("true")
                    } else {
                        printf("false")
                    }
                }
                
                case Basic_Type_Info.S8:
                case Basic_Type_Info.S16:
                case Basic_Type_Info.S32:
                case Basic_Type_Info.S64: {
                    printf("%lld", data_to_s64(type.Basic, data));
                    
                    
                }
                
                case Basic_Type_Info.U8:
                case Basic_Type_Info.U16:
                case Basic_Type_Info.U32:
                case Basic_Type_Info.U64: {
                    printf("%llu", data_to_u64(type.Basic, data));
                }
                
                case Basic_Type_Info.F32:
                case Basic_Type_Info.F64: {
                    printf("%f", data_to_f64(type.Basic, data));
                }
                
                case Basic_Type_Info.String: {
                    string* s = (string*) data;
                    printf("%.*s", (int) s.count, s.data);
                }
                
                case Basic_Type_Info.CString: {
                    printf("%", *((cstring*) data));
                }
            }
        }
        
        case Type_Kind.Enum: {
            s64 value = 0;
            switch (type.Enum.type.kind) {
                case Basic_Type_Info.S8:
                case Basic_Type_Info.S16:
                case Basic_Type_Info.S32:
                case Basic_Type_Info.S64: {
                    value = data_to_s64(type.Enum.type.kind, data);
                }
                
                case Basic_Type_Info.U8:
                case Basic_Type_Info.U16:
                case Basic_Type_Info.U32:
                case Basic_Type_Info.U64: {
                    value = data_to_u64(type.Enum.type.kind, data);
                }
            }
            
            print("%.", type.Enum.ident);
            if (value >= 0 && value < type.Enum.names.count) {
                print("% (%)", type.Enum.names[value], value);
            } else {
                print("%", value);
            }
        }
        
        case Type_Kind.Array: {
            print("{ ");
            
            smm count = type.Array.fixed_count;
            if (count < 0) {
                count = *((smm*) data);
            }
            
            Type_Info* elem_type = type.Array.elem_type;
            
            const int max_elements_to_show = 5;
            
            for (int array_index = 0; 
                 array_index < count && array_index < max_elements_to_show; 
                 array_index++) {
                
                if (elem_type.kind != Type_Kind.Basic) {
                    print_newline_with_spaces(indent + 4);
                }
                
                smm offset = type.Array.elem_size*array_index;
                
                print_data_from_type_info(elem_type, (u8*) data + offset, indent + 4);
                if (array_index + 1 < count) {
                    print(", ");
                }
            }
            
            if (count >= max_elements_to_show) {
                if (elem_type.kind != Type_Kind.Basic) {
                    print_newline_with_spaces(indent + 4);
                }
                print("...+% more", count - max_elements_to_show);
            }
            
            if (elem_type.kind != Type_Kind.Basic) {
                print_newline_with_spaces(indent);
                print("}");
            } else {
                print(" }");
            }
        }
        
        case Type_Kind.Union:
        case Type_Kind.Struct: {
            print("% {", type.Struct.ident);
            indent += 4;
            for (int field_index = 0; field_index < type.Struct.fields.count; field_index++) {
                Struct_Field_Info field = type.Struct.fields[field_index];
                if (field.offset == 0 && type.kind == Type_Kind.Union && field_index > 0) {
                    break;
                }
                
                print_newline_with_spaces(indent);
                print("%: ", field.ident);
                print_data_from_type_info(field.type,  (u8*) data + field.offset, indent);
                
                if (field_index + 1 < type.Struct.fields.count) {
                    print(", ");
                }
            }
            indent -= 4;
            print_newline_with_spaces(indent);
            print("}");
        }
    }
    
    if (indent == 0) {
        print("\n");
    }
}

#define print_var(var) \
print_data_from_type_info(type_of(var), &var);