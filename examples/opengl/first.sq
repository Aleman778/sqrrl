#include <basic.sq>
#include <window.sq>
#include <opengl.sq>


string
win32_read_entire_file(cstring filename) {
    string result;
    HANDLE file_handle = CreateFileA(filename, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);
    
    if (file_handle != INVALID_HANDLE_VALUE) {
        LARGE_INTEGER file_size;
        if (GetFileSizeEx(file_handle, &file_size)) {
            result.count = (u32) file_size.QuadPart;
            result.data = (u8*) VirtualAlloc(0, result.count, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
            
            if (result.data) {
                if (!ReadFile(file_handle, result.data, (u32) result.count, 0, 0)) {
                    // TODO(alexander): logging, failed read file
                }
                
            } else {
                // TODO(alexander): logging, failed to allocate memory
            }
            
        } else {
            // TODO(alexander): logging, failed to get file size
        }
        
        CloseHandle(file_handle);
    } else {
        // TODO(alexander): logging, file not found
    }
    
    return result;
}

void
win32_free_file_memory(void* memory) {
    VirtualFree(memory, 0, MEM_RELEASE);
}

int
compile_shader_from_file(int program, int shader_type, cstring filename) {
    int shader = glCreateShader(shader_type);
    string source = win32_read_entire_file(filename);
    cstring source_cstring = string_to_cstring(source);
    
    glShaderSource(shader, 1, cast(GLchar**) &source_cstring, 0);
    glCompileShader(shader);
    win32_free_file_memory(source.data);
    cstring_free(source_cstring);
    
    GLint success;
    glGetShaderiv(shader, GL_COMPILE_STATUS, &success);
    if (!success) {
        // TODO: COMPILER BUG: wasn't possible to just use a stack allocated array?!??!
        string message;
        message.data = (u8*) malloc(1024);
        message.count = 0;
        glGetShaderInfoLog(shader, 1024, cast(GLsizei*) &message.count, cast(GLchar*) message.data);
        pln("%: %", filename, message);
        free(message.data);
        return false;
    }
    
    glAttachShader(program, shader);
    return shader;
}

enum Render_Op {
    Draw_Triangles,
}

struct v2 {
    f32 x, y;
}

struct v3 {
    f32 x, y, z;
}

struct v4 {
    f32 r, g, b, a;
}

struct Vertex {
    v3 pos;
    v2 texcoord;
    v4 tint;
}

struct Render_Queue {
    
}

struct Render_Command {
    Render_Op op;
    
    union {
        Vertex* vertices;
        f32* data;
    };
    
    int vertex_count;
}

struct Push_Buffer {
    [65536]u8 data;
    u32 curr_used;
}

// NOTE(Alexander): align has to be a power of two.
#define is_power_of_two(x) (((x) & ((x) - 1)) == 0)
#define assert_power_of_two(x) assert(is_power_of_two(x) && "x is not power of two")
inline umm
align_forward(umm address, umm align) {
    assert_power_of_two(align);
    umm modulo = address & (align - 1);
    if (modulo != 0) {
        address += align - modulo;
    }
    return address;
}

#if 0
void
push_size() {
    
}


Render_Command*
push_command(Render_Op op, Push_Buffer* buf) {
    Render_Command* command = push_size(buf.curr_used, Render_Command);
    command.op = op;
    return command;
}
#endif

struct OpenGL {
    GLuint vertex_array;
    GLuint vertex_buffer;
    GLuint index_buffer;
}

void
init_opengl(OpenGL* opengl) {
    // Vertex array
    glGenVertexArrays(1, &opengl.vertex_array);
    glBindVertexArray(opengl.vertex_array);
    
    // Setup buffers
    glGenBuffers(1, &opengl.vertex_buffer);
    
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), 0);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), 5 * sizeof(f32));
    glEnableVertexAttribArray(0);
    glEnableVertexAttribArray(1);
}

void
opengl_begin_drawing(OpenGL* opengl) {
    glClear(GL_COLOR_BUFFER_BIT);
}

void
opengl_end_drawing(OpenGL* opengl, Render_Command command) {
    
    glBindVertexArray(opengl.vertex_array);
    glBindBuffer(GL_ARRAY_BUFFER, opengl.vertex_buffer);
    glBufferData(GL_ARRAY_BUFFER,
                 command.vertex_count*sizeof(Vertex), 
                 command.data, GL_DYNAMIC_DRAW);
    
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), 0);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), 6 * sizeof(f32));
    glEnableVertexAttribArray(0);
    glEnableVertexAttribArray(1);
    glDrawArrays(GL_TRIANGLES, 0, command.vertex_count);
}

int
main() {
    
    f32 aspect_ratio = 16.0f / 9.0f;
    int height = 720;
    int width = (int) ((f32) height * aspect_ratio);
    
    init_window(width, height, "OpenGL Test");
    
    //Push_Buffer* push_buffer = calloc(1, sizeof(Push_Buffer)); // 64k
    
    OpenGL* opengl = (OpenGL*) calloc(1, sizeof(OpenGL));
    init_opengl(opengl);
    
    
    []f32 triangles = {
        1.0f, -1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f,
        -1.0f,  1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f,
        -1.0f, -1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f,
        
        -1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f,
        1.0f,  1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f,
        1.0f, -1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f,
    };
    Render_Command command = {};
    command.data = triangles.data;
    command.vertex_count = 6;
    
    
    // Setup shaders
    int program = glCreateProgram();
    int vs = compile_shader_from_file(program, GL_VERTEX_SHADER, "../examples/opengl/test.vs");
    int fs = compile_shader_from_file(program, GL_FRAGMENT_SHADER, "../examples/opengl/test.fs");
    
    if (vs && fs) {
        int success;
        glLinkProgram(program);
        glDeleteShader(vs);
        glDeleteShader(fs);
        
        glGetProgramiv(program, GL_LINK_STATUS, &success);
        if (!success) {
            string message;
            message.data = (u8*) malloc(1024);
            message.count = 0;
            glGetProgramInfoLog(program, 1024, cast(GLsizei*) &message.count, cast(GLchar*) message.data);
            pln("%", message);
            free(message.data);
            return false;
        }
    }
    
    int uniform_t = glGetUniformLocation(program, (GLchar*) string_to_cstring("t"));
    
    glUseProgram(program);
    glUniform1f(uniform_t, 0.0f);
    
    
    f32 time = 0.0f;
    while (!window_should_close()) {
        
        time += 0.1f;
        glUniform1f(uniform_t, time);
        
        opengl_begin_drawing(opengl);
        
        glClearColor(0.0f, 0.5f, 1.0f, 1.0f);
        
        glUseProgram(program);
        
        opengl_end_drawing(opengl, command);
        
        window_swap_buffers();
    }
    
    ExitProcess(0);
}
