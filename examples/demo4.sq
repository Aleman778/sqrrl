
#if 0
// Windows needs to know abit about our compilation target
#define _MSC_VER 1929
#define _MSC_FULL_VER 192930133

#define _M_AMD64 100
#define _AMD64_
#define _M_IX86 100 

#define WINDOWS_IGNORE_PACKING_MISMATCH 1 // windows.h has strange assertions that compiler has a hard time parsing
#define WINVER 0x0A00
#define _WIN32_WINNT 0x0A00



#define NOCOMM // no COM API crap
#define WIN32_LEAN_AND_MEAN // maybe we will get rid of some garbage?

#include "windows.h"

#else
#include "tinywindows.h"
#endif

#include "raytracer/first.sq"

//#define PRINT_AST 1
//#define PRINT_BYTECODE 1

bool is_running = true;

LRESULT CALLBACK
win32_main_callback(HWND window, UINT message, WPARAM w_param, LPARAM l_param) {
    LRESULT result = 0;
    
    if (message == WM_CLOSE) {
        is_running = false;
    } else if (message == WM_DESTROY) {
        is_running = false;
    } else {
        result = DefWindowProcA(window, message, w_param, l_param);
    }
    
    return result;
}


struct Win32_Offscreen_Buffer {
    BITMAPINFO info;
    void* memory;
    int width;
    int height;
    int bytes_per_row;
    int bytes_per_pixel;
    int scale;
}

void
win32_resize_offscreen_buffer(Win32_Offscreen_Buffer* buffer, 
                              HDC window_device_context, 
                              int width, int height) {
    // TODO(alexander): maybe don't free first, free after, then free first if that fails.
    if (buffer.memory) {
        VirtualFree(buffer.memory, 0, MEM_RELEASE);
    }
    
    buffer.width = width;
    buffer.height = height;
    buffer.bytes_per_pixel = 4;
    
    buffer.info.bmiHeader.biSize = (u32) sizeof(buffer.info.bmiHeader);
    buffer.info.bmiHeader.biWidth = buffer.width;
    buffer.info.bmiHeader.biHeight = -buffer.height;
    buffer.info.bmiHeader.biPlanes = 1;
    buffer.info.bmiHeader.biBitCount = 32;
    buffer.info.bmiHeader.biCompression = BI_RGB;
    
    // TODO(Alexander): probably not where we should do this!
    int buffer_memory_size = (buffer.width*buffer.height)*buffer.bytes_per_pixel;
    buffer.memory = VirtualAlloc(0, buffer_memory_size, MEM_COMMIT, PAGE_READWRITE);
    
    buffer.bytes_per_row = buffer.width*buffer.bytes_per_pixel;
}

struct v4 {
    f32 r;
    f32 g;
    f32 b;
    f32 a;
}


inline u32
round_f32_to_u32(f32 value) {
    return (u32) round_f32(value);
}

inline u32
rgba_pack_u32(v4 c) {
    return (round_f32_to_u32(c.a * 255.0f) << 24 |
            round_f32_to_u32(c.r * 255.0f) << 16 |
            round_f32_to_u32(c.g * 255.0f) << 8 |
            round_f32_to_u32(c.b * 255.0f));
}


void
win32_clear_color(Win32_Offscreen_Buffer* buffer, v4 color) {
    u32 pixel_value = rgba_pack_u32(color);
    //pln("%", (u32*) pixel_value);
    s64 p = (s64) buffer.width*(s64) buffer.bytes_per_pixel;
    u8* pitch = (u8*) p;
    u8* row = (u8*) buffer.memory;
    for (s32 y = 0; y < buffer.height; y += 1) {
        u32* pixel = (u32*) row;
        for (s32 x = 0; x < buffer.width; x += 1) {
            *pixel = pixel_value;
            pixel += 4;
        }
        row += (u8*) pitch;
    }
}


void
win32_render_buffer(Win32_Offscreen_Buffer* buffer, HDC window_device_context) {
    StretchDIBits(window_device_context,
                  0, 0, buffer.width, buffer.height,
                  0, 0, buffer.width, buffer.height,
                  buffer.memory,
                  &buffer.info,
                  DIB_RGB_COLORS, 
                  SRCCOPY | BLACKNESS);
}

int
main() {
    HINSTANCE h_instance = GetModuleHandleA(0);
    
    WNDCLASSA wndclass;
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = win32_main_callback;
    wndclass.hInstance = h_instance;
    wndclass.lpszClassName = "PlatfomerWindowClass";
    
    int width = 640;
    int height = 380;
    
    if (RegisterClassA(&wndclass)) {
        //debug_break();
        HWND window = CreateWindowExA(0,
                                      "PlatfomerWindowClass",
                                      "Platformer",
                                      WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                                      CW_USEDEFAULT,
                                      CW_USEDEFAULT,
                                      width, height,
                                      0, 0,
                                      wndclass.hInstance,
                                      0);
        
        HDC device_context = GetDC(window);
        
        Win32_Offscreen_Buffer offscreen_buffer;
        win32_resize_offscreen_buffer(&offscreen_buffer, device_context, width, height);
        
        v4 sky_color;//v4 { r: 0.0f, g: 0.5f, b: 1.0f, a: 1.0f };
        sky_color.r = 0.0f;
        sky_color.g = 0.5f;
        sky_color.b = 1.0f;
        sky_color.a = 1.0f;
        //win32_clear_color(&offscreen_buffer, sky_color);
        render(&offscreen_buffer);
        
        int i = 0;
        while (is_running) {
            
            win32_render_buffer(&offscreen_buffer, device_context);
            
            //win32_clear_color(&offscreen_buffer, sky_color);
            
            //pln("Frame %", i + 1);
            
            MSG message;
            while (PeekMessageA(&message, 0, 0, 0, PM_REMOVE)) {
                if (message.message == WM_QUIT) {
                    is_running = false;
                } else {
                    TranslateMessage(&message);
                    DispatchMessageA(&message);
                }
            }
            
            Sleep(10);
            i += 1;
        }
        
    } else {
        pln("Failed to create a window")
    }
    
}
