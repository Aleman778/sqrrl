// Based on https://raytracing.github.io/books/RayTracingInOneWeekend.html

#define PI_F32 3.1415926535897932385f
#define INF_F32 100000000000000000000000000000000000.0f

f32
degrees_to_radians(f32 degrees) {
    return degrees * PI_F32 / 180.0f;
}

f32
random_f32_between(f32 minimum, f32 maximum) {
    assert(maximum >= minimum);
    return minimum + (maximum-minimum)*random_f32();
}

f32
clamp_f32(f32 v, f32 min, f32 max) {
    if (v < min) {
        v = min;
    } else if (v > max) {
        v = max;
    }
    return v;
}

#include "vecmath.sq"

//#define PRINT_AST 1
//#define PRINT_BYTECODE 1
//#define PRINT_ASM_VREG 1
//#define PRINT_ASM 1

v3
random_vec3_in_unit_sphere() {
    while (true) {
        v3 v;
        v.x = random_f32();
        v.y = random_f32();
        v.z = random_f32();
        if (vec3_length_squared(v) >= 1.0f) {
            continue;
        }
        return v;
    }
}

v3
random_unit_vec3() {
    //v3 rnd = ;
    return vec3_normalize(random_vec3_in_unit_sphere());
}


v3
ray_sky_color(ray r) {
    v3 dir = r.direction;
    dir = vec3_normalize(dir);
    
    f32 t = 0.5f*(dir.y + 1.0f);
    f32 t_inv = 1.0f-t;
    
    //v3 sky_color_0 = vec3(0.98f, 0.61f, 0.51f);
    //v3 sky_color_1 = vec3(52.0f/255.0f, 94.0f/255.0f, 173.0f/255.0f);
    
    v3 sky_color_0 = vec3(1.0f, 1.0f, 1.0f);
    v3 sky_color_1 = vec3(0.5f, 0.7f, 1.0f);
    
    v3 color_0 = vec3_scale(sky_color_0, t_inv);
    v3 color_1 = vec3_scale(sky_color_1, t);
    v3 color = vec3_add(color_0, color_1);
    return color;
}

struct Hit_Result {
    v3 p;
    v3 normal;
    f32 t;
}

struct Sphere {
    v3 p;
    f32 radius;
}

Hit_Result
hit_sphere(Sphere sphere, ray r, f32 t_min, f32 t_max) {
    Hit_Result result;
    result.t = -1.0f;
    
    v3 oc = vec3_sub(r.origin, sphere.p);
    
    f32 a = vec3_length_squared(r.direction);
    f32 half_b = vec3_dot(oc, r.direction);
    f32 c = vec3_length_squared(oc) - sphere.radius*sphere.radius;
    f32 discriminant = half_b*half_b - a*c;
    
    if (discriminant < 0.0f) {
        return result;
    }
    
    // TODO(Alexander): something wrong with this calculation
    // we shouldn't need to reverse order of root +/-
    f32 sqrt_discriminant = sqrt(discriminant);
    f32 root = (-half_b + sqrt_discriminant) / a;
    if (root < t_min || root >= t_max) {
        root = (-half_b - sqrt_discriminant) / a;
        if (root < t_min || root >= t_max) {
            return result;
        }
    }
    
    result.t = root;
    result.p = ray_at(r, root);
    
#if 0
    if (result.p.z > -0.60f) {
        pln("ray_at:");
        print_vec3(r.origin);
        print_vec3(r.direction);
        pln("root = %", root);
        print_vec3(result.p);
        pln("\n\n");
    }
#endif
    
    result.normal = vec3_sub(result.p, sphere.p);
    result.normal = vec3_scale(result.normal, 1.0f/sphere.radius);
    
    
#if 0
    //f32 sum = vec3_dot(color, color);
    //pln("%", sum);
    v3 color = result.normal;
    if (color.x <= 0.91f) {
        if (color.y <= 0.91f) {
            if (color.z <= 0.91f) {
                if (result.p.z < -1.4f) {
                    pln("black:");
                    print_vec3(result.normal);
                    print_vec3(result.p);
                    pln("test:");
                    
                    root = (-half_b - sqrt_discriminant) / a;
                    bool first = root < t_min || root >= t_max;
                    pln("1: % < % < % = %", t_min, root, t_max, first);
                    root = (-half_b + sqrt_discriminant) / a;
                    bool second = root < t_min || root >= t_max;
                    pln("2: % < % < % = %", t_min, root, t_max, second);
                    pln("end");
                }
            }
        }
    }
#endif
    
    
    //if (result.normal.z > 0.0f) {
    //pln("z > 0.0f, root = %", root);
    //print_vec3(result.normal);
    //}
    //result.normal = vec3(0.0f, 1.0f, 0.0f);
    // Only draw front faces
    //f32 dot = vec3_dot(r.direction, result.normal);
    //if (dot > 0.0f) {
    //result.t = -1.0f;
    //} else {
    //result.t = -1.0f;
    //}
    
    return result;
}

v3
ray_color(ray r, [2]Sphere spheres, int depth) {
    //print_vec3(spheres[0].p);
    if (depth <= 0) {
        return vec3(0.0f, 0.0f, 0.0f);
    }
    
    f32 t_min = 0.001f;
    f32 t_max = INF_F32;
    
    Hit_Result found_hit;
    found_hit.t = 0.0f-1.0f;
    
    for (int i = 0; i < (int) spheres.count; i += 1) {
        Sphere s = spheres[i];
        //pln("sphere% - pos: %, %, % - radius: %", i, s.p.x, s.p.y, s.p.z, s.radius);
        Hit_Result hit = hit_sphere(s, r, t_min, t_max);
        if (hit.t > 0.0f) {
            t_max = hit.t;
            found_hit = hit;
        }
    }
    
    v3 color;
    if (found_hit.t > 0.0f) {
        v3 target = vec3_add(found_hit.p, vec3_add(found_hit.normal, random_unit_vec3()));
        ray r_bounce;
        r_bounce.origin = found_hit.p;
        r_bounce.direction = vec3_sub(target, found_hit.p);
        
        depth -= 1;
        v3 c = ray_color(r_bounce, spheres, depth);
        color = vec3_scale(c, 0.5f);
        //color = found_hit.normal;
    } else {
        //color = vec3_add(color, ray_sky_color(r));
        color = ray_sky_color(r);
    }
    
    return color;
}

struct Game_State {
    v3 camera_p;
    
    [2]Sphere spheres;
    
    int samples_per_pixel;
}

struct HDR_Software_Texture {
    f32* data;
    s32 width;
    s32 height; 
    s32 pitch;
}

int
render(HDR_Software_Texture* texture, Game_State* state) {
    //debug_break();
    
    //f32 aspect_ratio = 16.0f / 9.0f;
    f32 aspect_ratio = (f32) texture.width / (f32) texture.height;
    int max_ray_depth = 50;
    
    //pln("resolution: % x %", texture.width, texture.height);
    
    f32 viewport_height = 2.0f;
    f32 viewport_width = aspect_ratio * viewport_height;
    
    v3 origin = state.camera_p;//vec3(0.0f, 0.0f, 0.0f);
    v3 horizontal = vec3(viewport_width, 0.0f, 0.0f);
    v3 vertical = vec3(0.0f, viewport_height, 0.0f);
    v3 focal = vec3(0.0f, 0.0f, 1.0f);
    
    // Compute the lower left screen coordinate
    v3 temp = vec3_scale(horizontal, 0.5f);
    v3 lower_left_corner = vec3_sub(origin, temp);
    temp = vec3_scale(vertical, 0.5f);
    lower_left_corner = vec3_sub(lower_left_corner, temp);
    lower_left_corner = vec3_sub(lower_left_corner, focal);
    
    //pln("P3\n% %\n255", texture.width, texture.height);
    state.samples_per_pixel += 1;
    
    f32* row = texture.data;
    for (int y = texture.height-1; y >= 0; y -= 1) {
        
        f32* texel = (f32*) row;
        for (int x = 0; x < texture.width; x += 1) {
            
            v3 color;
            color.x = *texel;
            color.y = *(texel + 4);
            color.z = *(texel + 8);
            
            //debug_break();
            f32 u = ((f32) x + random_f32()) / (f32) texture.width;
            f32 v = ((f32) y + random_f32()) / (f32) texture.height;
            
            temp = vec3_scale(horizontal, u);
            v3 dir = vec3_add(lower_left_corner, temp);
            temp = vec3_scale(vertical, v);
            dir = vec3_add(dir, temp);
            dir = vec3_sub(dir, origin);
            
            //print_vec3(dir);
            ray r;
            r.origin = origin;
            r.direction = dir;
            
            v3 c = ray_color(r, state.spheres, max_ray_depth);
            color = vec3_add(color, c);
            
            *texel = color.x;
            texel += 4;
            *texel = color.y;
            texel += 4;
            *texel = color.z;
            texel += 8;
            
            //pln("% % %", ir, ig, ib);
            //return 0;
        }
        
        s64 p = (s64) texture.pitch;
        row += (f32*) p;
    }
    
    return 0;
}
