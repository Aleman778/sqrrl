
#if 0
// Windows needs to know abit about our compilation target
#define _MSC_VER 1929
#define _MSC_FULL_VER 192930133

#define _M_AMD64 100
#define _AMD64_
#define _M_IX86 100 

#define WINDOWS_IGNORE_PACKING_MISMATCH 1 // windows.h has strange assertions that compiler has a hard time parsing
#define WINVER 0x0A00
#define _WIN32_WINNT 0x0A00



#define NOCOMM // no COM API crap
#define WIN32_LEAN_AND_MEAN // maybe we will get rid of some garbage?

#include "windows.h"

#else
#include "tinywindows.h"
#endif

#include "raytracer/first.sq"

//#define PRINT_AST 1
//#define PRINT_BYTECODE 1

bool is_running = true;

LRESULT CALLBACK
win32_main_callback(HWND window, UINT message, WPARAM w_param, LPARAM l_param) {
    LRESULT result = 0;
    
    if (message == WM_CLOSE) {
        is_running = false;
    } else if (message == WM_DESTROY) {
        is_running = false;
    } else {
        result = DefWindowProcA(window, message, w_param, l_param);
    }
    
    return result;
}


struct Win32_Offscreen_Buffer {
    BITMAPINFO info;
    void* memory;
    int width;
    int height;
    int bytes_per_row;
    int bytes_per_pixel;
    int scale;
}

void
win32_resize_offscreen_buffer(Win32_Offscreen_Buffer* buffer, 
                              HDC window_device_context, 
                              int width, int height) {
    // TODO(alexander): maybe don't free first, free after, then free first if that fails.
    if (buffer.memory) {
        VirtualFree(buffer.memory, 0, MEM_RELEASE);
    }
    
    buffer.width = width;
    buffer.height = height;
    buffer.bytes_per_pixel = 4;
    
    buffer.info.bmiHeader.biSize = (u32) sizeof(buffer.info.bmiHeader);
    buffer.info.bmiHeader.biWidth = buffer.width;
    buffer.info.bmiHeader.biHeight = -buffer.height;
    buffer.info.bmiHeader.biPlanes = 1;
    buffer.info.bmiHeader.biBitCount = 32;
    buffer.info.bmiHeader.biCompression = BI_RGB;
    
    // TODO(Alexander): probably not where we should do this!
    int buffer_memory_size = (buffer.width*buffer.height)*buffer.bytes_per_pixel;
    buffer.memory = VirtualAlloc(0, buffer_memory_size, MEM_COMMIT, PAGE_READWRITE);
    
    buffer.bytes_per_row = buffer.width*buffer.bytes_per_pixel;
}

struct v4 {
    f32 r;
    f32 g;
    f32 b;
    f32 a;
}


inline u32
round_f32_to_u32(f32 value) {
    return (u32) round_f32(value);
}

inline u32
rgba_pack_u32(v4 c) {
    return (round_f32_to_u32(c.a * 255.0f) << 24 |
            round_f32_to_u32(c.r * 255.0f) << 16 |
            round_f32_to_u32(c.g * 255.0f) << 8 |
            round_f32_to_u32(c.b * 255.0f));
}


void
win32_clear_color(Win32_Offscreen_Buffer* buffer, v4 color) {
    u32 pixel_value = rgba_pack_u32(color);
    //pln("%", (u32*) pixel_value);
    s64 p = (s64) buffer.width*(s64) buffer.bytes_per_pixel;
    u8* pitch = (u8*) p;
    u8* row = (u8*) buffer.memory;
    for (s32 y = 0; y < buffer.height; y += 1) {
        u32* pixel = (u32*) row;
        for (s32 x = 0; x < buffer.width; x += 1) {
            *pixel = pixel_value;
            pixel += 4;
        }
        row += (u8*) pitch;
    }
}

void
win32_render_buffer(Win32_Offscreen_Buffer* dest_buffer, HDR_Software_Texture* src_buffer, HDC window_device_context, int width, int height, int samples_per_pixel) {
    int size = dest_buffer.width*dest_buffer.height;
    
    f32* src = src_buffer.data;
    u32* dest = (u32*) (dest_buffer.memory);
    for (int i = 0; i < size; i += 1) {
        
        f32 scale = 1.0f / (f32) samples_per_pixel;
        
        // Divide the color by the number of samples and gamma-correct for gamma=2.0.
        f32 r = sqrt(*src * scale); src += 4;
        f32 g = sqrt(*src * scale); src += 4;
        f32 b = sqrt(*src * scale); src += 8;
        
        u32 ir = (u32) (256.0f*clamp_f32(r, 0.0f, 0.999f));
        u32 ig = (u32) (256.0f*clamp_f32(g, 0.0f, 0.999f));
        u32 ib = (u32) (256.0f*clamp_f32(b, 0.0f, 0.999f));
        
        *dest = ir << 16 | ig << 8 | ib; dest += 4;
    }
    
    StretchDIBits(window_device_context,
                  0, 0, width, height,
                  0, 0, dest_buffer.width, dest_buffer.height,
                  dest_buffer.memory,
                  &dest_buffer.info,
                  DIB_RGB_COLORS, 
                  SRCCOPY | BLACKNESS);
}

struct Game_Button_State {
    s32 num_half_transitions;
    bool ended_down;
}

inline bool
was_pressed(Game_Button_State state) {
    return state.num_half_transitions > 1 ||
    (state.num_half_transitions == 1 && state.ended_down);
}

inline bool
was_released(Game_Button_State state) {
    return state.num_half_transitions > 1 ||
    (state.num_half_transitions == 1 && !state.ended_down);
}

inline bool
is_down(Game_Button_State state) {
    return state.ended_down;
}

struct Game_Controller {
    Game_Button_State move_up;
    Game_Button_State move_right;
    Game_Button_State move_down;
    Game_Button_State move_left;
}

void
win32_process_keyboard_message(Game_Button_State* new_state, bool is_down) {
    if (new_state.ended_down != is_down) {
        new_state.num_half_transitions += 1;
        new_state.ended_down = is_down;
    }
}

int
main() {
    HINSTANCE h_instance = GetModuleHandleA(0);
    
    WNDCLASSA wndclass;
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = win32_main_callback;
    wndclass.hInstance = h_instance;
    wndclass.lpszClassName = "PlatfomerWindowClass";
    
    f32 aspect_ratio = 16.0f / 9.0f;
    int width = 400;
    int height = (int) ((f32) width / aspect_ratio);
    
    if (RegisterClassA(&wndclass)) {
        //debug_break();
        HWND window = CreateWindowExA(0,
                                      "PlatfomerWindowClass",
                                      "Platformer",
                                      WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                                      CW_USEDEFAULT,
                                      CW_USEDEFAULT,
                                      width, height,
                                      0, 0,
                                      wndclass.hInstance,
                                      0);
        
        HDC device_context = GetDC(window);
        
        Win32_Offscreen_Buffer offscreen_buffer;
        win32_resize_offscreen_buffer(&offscreen_buffer, device_context, width, height);
        
        v4 sky_color;//v4 { r: 0.0f, g: 0.5f, b: 1.0f, a: 1.0f };
        sky_color.r = 0.0f;
        sky_color.g = 0.5f;
        sky_color.b = 1.0f;
        sky_color.a = 1.0f;
        //win32_clear_color(&offscreen_buffer, sky_color);
        
        Game_State state;
        state.spheres[0].p = vec3(0.0f, 0.0f, -1.0f);
        state.spheres[0].radius = 0.5f;
        
        state.spheres[1].p = vec3(0.0f, -100.5f, -1.0f);
        state.spheres[1].radius = 100.0f;
        
        
        Game_Controller controller;
        
        HDR_Software_Texture texture;
        texture.width = width;
        texture.height = height;
        texture.pitch = texture.width*4*4;
        int buffer_memory_size = (texture.width*texture.height)*4*4;
        texture.data = (f32*) VirtualAlloc(0, buffer_memory_size, MEM_COMMIT, PAGE_READWRITE);
        
        int i = 0;
        while (is_running) {
            
            {
                Game_Controller new_controller;
                new_controller->move_up.ended_down = controller->move_up.ended_down;
                new_controller->move_left.ended_down = controller->move_left.ended_down;
                new_controller->move_down.ended_down = controller->move_down.ended_down;
                new_controller->move_right.ended_down = controller->move_right.ended_down;
                controller = new_controller;
            }
            
            RECT dimensions;
            if (GetClientRect(window, &dimensions)) {
                width = dimensions.right;
                height = dimensions.bottom;
            }
            
            render(&texture, &state);
            win32_render_buffer(&offscreen_buffer, &texture, device_context, width, height,
                                state.samples_per_pixel);
            
            //win32_clear_color(&offscreen_buffer, sky_color);
            
            //pln("Frame %", i + 1);
            
            MSG message;
            while (PeekMessageA(&message, 0, 0, 0, PM_REMOVE)) {
                if (message.message == WM_QUIT) {
                    is_running = false;
                    
                } else if (message.message == WM_SYSKEYDOWN ||
                           message.message == WM_SYSKEYUP ||
                           message.message == WM_KEYDOWN ||
                           message.message == WM_KEYUP) {
                    
                    u32 vkcode = (u32) message.wParam;
                    bool was_down = (message.lParam & (1 << 30)) != 0;
                    bool is_down = (message.lParam & (1 << 31)) == 0;
                    
                    if (was_down != is_down) {
                        if (vkcode == 'W') {
                            win32_process_keyboard_message(&controller.move_up, is_down);
                        } else if (vkcode == 'A') {
                            win32_process_keyboard_message(&controller.move_left, is_down);
                        } else if (vkcode == 'S') {
                            win32_process_keyboard_message(&controller.move_down, is_down);
                        } else if (vkcode == 'D') {
                            win32_process_keyboard_message(&controller.move_right, is_down);
                        }
                    }
                } else {
                    TranslateMessage(&message);
                    DispatchMessageA(&message);
                }
            }
            
            bool discard_buffer = false;
            if (is_down(controller.move_up)) {
                state.camera_p.z -= 0.1f;
                discard_buffer = true;
            }
            
            if (is_down(controller.move_down)) {
                state.camera_p.z += 0.1f;
                discard_buffer = true;
            }
            
            if (is_down(controller.move_left)) {
                state.camera_p.x -= 0.1f;
                discard_buffer = true;
            }
            
            if (is_down(controller.move_right)) {
                state.camera_p.x += 0.1f;
                discard_buffer = true;
            }
            
            if (discard_buffer) {
                state.samples_per_pixel = 0;
                int size = texture.width*texture.height;
                f32* src = texture.data;
                for (int j = 0; j < size; j += 1) {
                    *src = 0.0f; src += 4;
                    *src = 0.0f; src += 4;
                    *src = 0.0f; src += 8;
                }
            }
            
            Sleep(1);
            i += 1;
        }
        
    } else {
        pln("Failed to create a window")
    }
    
}
