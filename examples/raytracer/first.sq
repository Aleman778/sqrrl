// Based on https://raytracing.github.io/books/RayTracingInOneWeekend.html

#define pln(format, ...) print_format(format##"\n", ##__VA_ARGS__)

#define PI_F32 3.1415926535897932385f
#define INF_F32 100000000000000000000000000000000000.0f

f32
degrees_to_radians(f32 degrees) {
    return degrees * PI_F32 / 180.0f;
}

f32
random_f32_between(f32 minimum, f32 maximum) {
    assert(maximum >= minimum);
    return minimum + (maximum-minimum)*random_f32();
}

#include "vecmath.sq"

//#define PRINT_AST 1
//#define PRINT_BYTECODE 1
//#define PRINT_ASM_VREG 1
#define PRINT_ASM 1

v3
ray_sky_color(ray r) {
    v3 dir = r.direction;
    dir = vec3_normalize(dir);
    
    f32 t = 0.5f*(dir.y + 1.0f);
    f32 t_inv = 1.0f-t;
    
    v3 sky_color_0 = vec3(1.0f, 1.0f, 1.0f);
    v3 sky_color_1 = vec3(0.5f, 0.7f, 1.0f);
    v3 color_0 = vec3_scale(sky_color_0, t_inv);
    v3 color_1 = vec3_scale(sky_color_1, t);
    v3 color = vec3_add(color_0, color_1);
    return color;
}

struct Hit_Result {
    v3 p;
    v3 normal;
    f32 t;
}

struct Sphere {
    v3 p;
    f32 radius;
}

Hit_Result
hit_sphere(Sphere sphere, ray r, f32 t_min, f32 t_max) {
    Hit_Result result;
    result.t = -1.0f;
    
    v3 oc = vec3_sub(r.origin, sphere.p);
    f32 a = vec3_length_squared(r.direction);
    f32 half_b = vec3_dot(oc, r.direction);
    f32 c = vec3_length_squared(oc) - sphere.radius*sphere.radius;
    f32 discriminant = half_b*half_b - a*c;
    
    f32 cmp = 0.0f;
    if (discriminant < cmp) {
        return result;
    }
    
    f32 sqrt_discriminant = sqrt(discriminant);
    f32 root = (-half_b - sqrt_discriminant) / a;
    
    if (root < t_min || root >= t_max) {
        root = (-half_b + sqrt_discriminant) / a;
        if (root < t_min || root >= t_max) {
            return result;
        }
    }
    
    result.t = root;
    result.p = ray_at(r, root);
    result.normal = vec3_sub(result.p, sphere.p);
    result.normal = vec3_scale(result.normal, 1.0f/sphere.radius);
    return result;
}

v3
ray_color(ray r, [2]Sphere spheres, int depth) {
    if (depth <= 0) {
        return vec3(0.0f, 0.0f, 0.0f);
    }
    
    f32 t_min = 0.0f;
    f32 t_max = INF_F32;
    
    Hit_Result found_hit;
    found_hit.t = -1.0f;
    
    for (int i = 0; i < spheres.count; i += 1) {
        Hit_Result hit = hit_sphere(spheres[i], r, t_min, t_max);
        if (hit.t > 0.0f) {
            t_max = hit.t;
            found_hit = hit;
        }
    }
    
    v3 color;
    if (found_hit.t > 0.0f) {
        color.x += 0.5f*(found_hit.normal.x + 1.0f);
        color.y += 0.5f*(found_hit.normal.y + 1.0f);
        color.z += 0.5f*(found_hit.normal.z + 1.0f);
    } else {
        color = vec3_add(color, ray_sky_color(r));
    }
    
    return color;
}


int
main() {
    //debug_break();
    
    f32 aspect_ratio = 16.0f / 9.0f;
    int image_width = 400;
    int image_height = (int) (image_width / aspect_ratio);
    int samples_per_pixel = 100;
    int max_ray_depth = 50;
    
    f32 viewport_height = 2.0f;
    f32 viewport_width = aspect_ratio * viewport_height;
    
    v3 origin = vec3(0.0f, 0.0f, 0.0f);
    v3 horizontal = vec3(viewport_width, 0.0f, 0.0f);
    v3 vertical = vec3(0.0f, viewport_height, 0.0f);
    v3 focal = vec3(0.0f, 0.0f, 1.0f);
    
    // Compute the lower left screen coordinate
    v3 temp = vec3_scale(horizontal, 0.5f);
    v3 lower_left_corner = vec3_sub(origin, temp);
    temp = vec3_scale(vertical, 0.5f);
    lower_left_corner = vec3_sub(lower_left_corner, temp);
    lower_left_corner = vec3_sub(lower_left_corner, focal);
    
    pln("P3\n% %\n255", image_width, image_height);
    
    [2]Sphere spheres;
    spheres[0].p = vec3(0.0f, 0.0f, -1.0f);
    spheres[0].radius = 0.5f;
    
    spheres[1].p = vec3(0.0f, -100.5f, -1.0f);
    spheres[1].radius = 100.0f;
    
    for (int y = image_height-1; y >= 0; y -= 1) {
        for (int x = 0; x < image_width; x += 1) {
            // TODO(Alexander): bug (image_width) breaks
            // TODO(Alexander): bug (image_width - 1) breaks
            
            v3 color = vec3(0.0f, 0.0f, 0.0f);
            for (int sample_index = 0;
                 sample_index < samples_per_pixel;
                 sample_index += 1) {
                f32 u = ((f32) x + random_f32()) / (f32) image_width;
                f32 v = ((f32) y + random_f32()) / (f32) image_height;
                
                temp = vec3_scale(horizontal, u);
                v3 dir = vec3_add(lower_left_corner, temp);
                temp = vec3_scale(vertical, v);
                dir = vec3_add(dir, temp);
                dir = vec3_sub(dir, origin);
                
                ray r;
                r.origin = origin;
                r.direction = dir;
                
                ray_color(r, spheres, max_ray_depth);
            }
            
            color = vec3_scale(color, 1.0f/(f32) samples_per_pixel);
            
            // Write the color
            int ir = (int) (254.999f * color.x);
            int ig = (int) (254.999f * color.y);
            int ib = (int) (254.999f * color.z);
            
            pln("% % %", ir, ig, ib);
            //return 0;
        }
    }
    
    return 0;
}
