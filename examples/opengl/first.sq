#include <basic.sq>
#include <input.sq>
#include <window.sq>
#include <stb_image.sq>

// TODO(Alexander): COMPILER BUG: opengl.sq has to be loaded last messes up the import directory table
#include <opengl.sq>

#include "math.sq"


#define RED (v4) { 1.0f, 0.0f, 0.0f, 1.0f }
#define GREEN (v4) { 0.0f, 1.0f, 0.0f, 1.0f }
#define WHITE (v4) { 1.0f, 1.0f, 1.0f, 1.0f }


string
win32_read_entire_file(cstring filename) {
    string result;
    HANDLE file_handle = CreateFileA(filename, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);
    
    if (file_handle != INVALID_HANDLE_VALUE) {
        LARGE_INTEGER file_size;
        if (GetFileSizeEx(file_handle, &file_size)) {
            result.count = (u32) file_size.QuadPart;
            result.data = (u8*) VirtualAlloc(0, result.count, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
            
            if (result.data) {
                if (!ReadFile(file_handle, result.data, (u32) result.count, 0, 0)) {
                    // TODO(alexander): logging, failed read file
                }
                
            } else {
                // TODO(alexander): logging, failed to allocate memory
            }
            
        } else {
            // TODO(alexander): logging, failed to get file size
        }
        
        CloseHandle(file_handle);
    } else {
        // TODO(alexander): logging, file not found
    }
    
    return result;
}

void
win32_free_file_memory(void* memory) {
    VirtualFree(memory, 0, MEM_RELEASE);
}

int
compile_shader_from_file(int program, int shader_type, cstring filename) {
    int shader = glCreateShader(shader_type);
    string source = win32_read_entire_file(filename);
    cstring source_cstring = string_to_cstring(source);
    
    glShaderSource(shader, 1, cast(GLchar**) &source_cstring, 0);
    glCompileShader(shader);
    win32_free_file_memory(source.data);
    cstring_free(source_cstring);
    
    GLint success;
    glGetShaderiv(shader, GL_COMPILE_STATUS, &success);
    if (!success) {
        // TODO: COMPILER BUG: wasn't possible to just use a stack allocated array?!??!
        string message;
        message.data = (u8*) malloc(1024);
        message.count = 0;
        glGetShaderInfoLog(shader, 1024, cast(GLsizei*) &message.count, cast(GLchar*) message.data);
        pln("%: %", filename, message);
        free(message.data);
        return false;
    }
    
    glAttachShader(program, shader);
    return shader;
}

enum Render_Op {
    Draw_Triangles,
}

struct Vertex {
    v3 pos;
    v2 texcoord;
    v4 tint;
}

struct Render_Queue {
    
}

struct Render_Command {
    Render_Op op;
    
    union {
        Vertex* vertices;
        f32* vertex_data;
    };
    
    u16* indices;
    
    m4x4 transform; // TODO: this should not be placed here
    
    u32 vertex_count;
    u32 index_count;
}

struct Push_Buffer {
    [65536]u8 base;
    u32 used;
}

// NOTE(Alexander): align has to be a power of two.
#define is_power_of_two(x) (((x) & ((x) - 1)) == 0)
#define assert_power_of_two(x) assert(is_power_of_two(x) && "x is not power of two")
inline umm
align_forward(umm address, umm align) {
    assert_power_of_two(align);
    umm modulo = address & (align - 1);
    if (modulo != 0) {
        address += align - modulo;
    }
    return address;
}

void*
push_size(Push_Buffer* buf, umm size, umm align) {
    umm base_offset = (umm) buf.base.data + (umm) buf.used;
    umm offset = align_forward(base_offset, align) - (umm) buf.base.data;
    assert((smm) (offset + size) <= buf.base.count);
    buf.used = (u32) (offset + size);
    
    void* result = buf.base.data + offset;
    memset(result, 0, size);
    return result;
}

#define push_struct(buf, T) (T*) push_size(buf, sizeof(T), alignof(T))

Render_Command*
push_command(Push_Buffer* buf, Render_Op op) {
    Render_Command* command = push_struct(buf, Render_Command);
    command.op = op;
    command.vertex_data = (f32*) push_size(buf, 1024, alignof(f32));
    command.indices = (u16*) push_size(buf, 512, alignof(u16));
    return command;
}

struct OpenGL {
    GLuint vertex_array;
    
    
    union {
        struct {
            GLuint vertex_buffer;
            GLuint index_buffer;
        };
        [2]GLuint buffers;
    };
    
    GLuint texture;
    
    GLuint program;
    GLuint uniform_texture;
    GLuint uniform_projection;
}

void
init_opengl(OpenGL* opengl) {
    // Vertex array
    glGenVertexArrays(1, &opengl.vertex_array);
    glBindVertexArray(opengl.vertex_array);
    
    // Setup buffers
    glGenBuffers(opengl.buffers.count, cast(GLuint*) &opengl.buffers);
    
    // Setup textures
    glGenTextures(1, &opengl.texture);
    
    // Enable depth testing
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LESS);
    
    // Enable face culling
    glEnable(GL_CULL_FACE);
    glCullFace(GL_BACK);
    glFrontFace(GL_CCW);
}

void
opengl_begin_drawing(OpenGL* opengl, Push_Buffer* buf) {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);  
    
    buf.used = 0;
}

void
opengl_end_drawing(OpenGL* opengl, Render_Command* command, m4x4 projection) {
    
    glBindVertexArray(opengl.vertex_array);
    glBindBuffer(GL_ARRAY_BUFFER, opengl.vertex_buffer);
    glBufferData(GL_ARRAY_BUFFER,
                 command.vertex_count*sizeof(Vertex), 
                 command.vertex_data, GL_DYNAMIC_DRAW);
    
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, opengl.index_buffer);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER,
                 command.index_count*sizeof(s16), 
                 command.indices, GL_DYNAMIC_DRAW);
    
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), 0);
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), 3 * sizeof(f32));
    glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), 5 * sizeof(f32));
    glEnableVertexAttribArray(0);
    glEnableVertexAttribArray(1);
    glEnableVertexAttribArray(2);
    
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, opengl.texture);
    
    glUseProgram(opengl.program);
    glUniform1i(opengl.uniform_texture, 0);
    
    
    glUniformMatrix4fv(opengl.uniform_projection, 1, true, &projection.data[0]);
    
    glDrawElements(GL_TRIANGLES, command.index_count, GL_UNSIGNED_SHORT, 0);
}

inline void
push_vertex(Render_Command* command, v3 pos, v2 texcoord, v4 tint) {
    command.vertices[command.vertex_count].pos = (command.transform * vec4(pos, 1.0f)).xyz;
    command.vertices[command.vertex_count].texcoord = texcoord;
    command.vertices[command.vertex_count].tint = tint;
    command.vertex_count++;
}

inline void
push_indices(Render_Command* command, []u16 indices, u16 first_index=0) {
    for (int i = 0; i < indices.count; i++) {
        command.indices[command.index_count++] = first_index + indices[i];
    }
}


void
push_quad(Render_Command* command, v3 min_p, v3 right, v3 down, v4 tint) {
    []u16 indices = { 0, 1, 2, 1, 3, 2 };
    push_indices(command, ([]u16) indices, (u16) command.vertex_count);
    push_vertex(command, min_p,                vec2(0.0f, 0.0f), tint);
    push_vertex(command, min_p + right,        vec2(1.0f, 0.0f), tint);
    push_vertex(command, min_p + down,         vec2(0.0f, 1.0f), tint);
    push_vertex(command, min_p + right + down, vec2(1.0f, 1.0f), tint);
}

void
push_box(Render_Command* command, v3 size, v4 tint) {
    []u16 indices = { 
        0, 1, 2, 1, 3, 2, // front
        5, 4, 7, 4, 6, 7, // back
        4, 0, 6, 0, 2, 6, // left
        1, 5, 3, 5, 7, 3, // right
    };
    push_indices(command, ([]u16) indices, (u16) command.vertex_count);
    
    v3 min_p = vec3(-size.x*0.5f, -size.y*0.5f, -size.z*0.5f);
    v3 max_p = min_p + size;
    
    // Front
    push_vertex(command, min_p,                           vec2(0.0f, 0.0f), tint);
    push_vertex(command, vec3(max_p.x, min_p.y, min_p.z), vec2(1.0f, 0.0f), tint);
    push_vertex(command, vec3(min_p.x, max_p.y, min_p.z), vec2(0.0f, 1.0f), tint);
    push_vertex(command, vec3(max_p.x, max_p.y, min_p.z), vec2(1.0f, 1.0f), tint);
    
    // Back
    push_vertex(command, vec3(min_p.x, min_p.y, max_p.z), vec2(1.0f, 0.0f), tint);
    push_vertex(command, vec3(max_p.x, min_p.y, max_p.z), vec2(0.0f, 0.0f), tint);
    push_vertex(command, vec3(min_p.x, max_p.y, max_p.z), vec2(1.0f, 1.0f), tint);
    push_vertex(command, vec3(max_p.x, max_p.y, max_p.z), vec2(0.0f, 1.0f), tint);
    
    // Top
    push_quad(command, 
              vec3(min_p.x, max_p.y, min_p.z), 
              vec3(size.x, 0.0f, 0.0f), vec3(0.0f, 0.0f, size.z), tint);
    
    // Bottom
    push_quad(command, vec3(max_p.x, min_p.y, min_p.z), 
              vec3(-size.x, 0.0f, 0.0f), vec3(0.0f, 0.0f, size.z), tint);
    
    
    //push_quad(command, min_p, vec3(size.x, 0.0f, 0.0f), vec3(0.0f, size.y, 0.0f), tint);
    
    // Back
    
    //push_quad(command, max_p, vec3(-size.x, 0.0f, 0.0f), vec3(0.0f, -size.y, 0.0f), tint);
}

struct Loaded_Image {
    int width;
    int height;
    int num_components;
    int stride; 
    u8* data;
}

Loaded_Image
load_image(string filename) {
    Loaded_Image result;
    cstring cfilename = string_to_cstring(filename);
    u8* data = stbi_load(cfilename, &result.width, &result.height, &result.num_components, 0);
    cstring_free(cfilename);
    
    if (!data) {
        pln("Failed to load image `%`", filename);
    }
    
    result.data = data;
    result.stride = result.width * result.num_components;
    return result;
}

int
main() {
    
    f32 aspect_ratio = 16.0f / 9.0f;
    int height = 720;
    int width = (int) ((f32) height * aspect_ratio);
    
    init_window(width, height, "OpenGL Test");
    
    Push_Buffer* push_buffer = (Push_Buffer*) calloc(1, sizeof(Push_Buffer)); // 64k
    
    OpenGL* opengl = (OpenGL*) calloc(1, sizeof(OpenGL));
    init_opengl(opengl);
    
    Loaded_Image image = load_image("../examples/opengl/crate.jpg");
    // TODO: add support for freeing the image!
    
    GLenum internal_format = (image.num_components == 3) ? GL_RGB : GL_RGBA;
    glBindTexture(GL_TEXTURE_2D, opengl.texture);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    //glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    //glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    //
    glTexImage2D(GL_TEXTURE_2D, 0, internal_format, image.width, image.height, 0,
                 GL_RGB, GL_UNSIGNED_BYTE, image.data); // TODO: do we want ALPHA component in the format
    
    
    // Setup shaders
    opengl.program = glCreateProgram();
    int vs = compile_shader_from_file(opengl.program, GL_VERTEX_SHADER, "../examples/opengl/test.vs");
    int fs = compile_shader_from_file(opengl.program, GL_FRAGMENT_SHADER, "../examples/opengl/test.fs");
    if (vs && fs) {
        int success;
        glLinkProgram(opengl.program);
        glDeleteShader(vs);
        glDeleteShader(fs);
        
        glGetProgramiv(opengl.program, GL_LINK_STATUS, &success);
        if (!success) {
            string message;
            message.data = (u8*) malloc(1024);
            message.count = 0;
            glGetProgramInfoLog(opengl.program, 1024, cast(GLsizei*) &message.count, cast(GLchar*) message.data);
            pln("%", message);
            free(message.data);
            
            ExitProcess(0);
        }
    } else {
        ExitProcess(0);
    }
    opengl.uniform_texture = glGetUniformLocation(opengl.program, (GLchar*) string_to_cstring("u_texture"));
    opengl.uniform_projection = glGetUniformLocation(opengl.program, (GLchar*) string_to_cstring("u_projection"));
    
    v2 screen_size;
    
    local_persist f32 pitch;
    local_persist f32 roll;
    local_persist f32 scale;
    
    scale = 1.0f;
    roll = -PI_F32/16.0f;
    
    while (!window_should_close()) {
        screen_size.width = get_window_width();
        screen_size.height = get_window_height();
        
        m4x4 projection = m4x4_orthographic(0.0f, screen_size.height, screen_size.width, 0.0f,
                                            -99999.0f, 99999.0f);
        glViewport(0, 0, (int) screen_size.width, (int) screen_size.height);
        
        opengl_begin_drawing(opengl, push_buffer);
        
        Render_Command* command = push_command(push_buffer, Render_Op.Draw_Triangles);
        command.transform = 
            m4x4_translate(vec3(screen_size.x*0.5f, screen_size.y*0.5f, 0.0f)) * 
            m4x4_euler(0.0f, pitch, roll) *
            m4x4_scale(vec3(scale, scale, scale));
        
        scale = max(scale + 0.1f*get_mouse_wheel_delta(), 0.1f);
        
        if (is_mouse_down(MOUSE_RIGHT)) {
            pitch -= 0.003f * get_mouse_dx();
            roll -= 0.003f * get_mouse_dy();
        }
        
        //push_rectangle(command, vec2(0.0f, 0.0f), vec2(128.0f, 128.0f), WHITE);
        //push_quad(command, vec3(0.0f, 0.0f, 0.0f), vec3(128.0f, 0.0f, 0.0f), vec3(0.0f, 128.0f, 0.0f), WHITE);
        
        push_box(command, vec3(128.0f, 128.0f, 128.0f), WHITE);
        
        glClearColor(0.05f, 0.1f, 0.4f, 1.0f);
        
        opengl_end_drawing(opengl, command, projection);
        
        window_swap_buffers();
    }
    
    ExitProcess(0);
}
