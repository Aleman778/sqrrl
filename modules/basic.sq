
// Assert
//#if BUILD_DEBUG
bool
__assert(cstring expression, string file, smm line) {
    // TODO(Alexander): improve assertion printing.
    print("%:%: Assertion failed: %\n", file, line, expression);
    //_put_string("Assertion failed!");
    //DEBUG_log_backtrace();
    
    // Flush the standard streams make sure we get all debug data
    //fflush(stdout);
    //fflush(stderr);
    
    *(int *)0 = 0; // NOTE(Alexander): purposefully trap the program
    return true;
}
#define assert(expr, ...) (void) ((expr) || __assert(#expr " - " __VA_ARGS__, __FILE__, __LINE__))
//#else
//#define assert(expression)
//#endif


// TODO(Alexander): we only have windows support atm. later on we import the correct header
#include <basic_windows.sq>
#include <ucrtwindows.h>

f32
cos(f32 num) {
    return _cos_f32(num);
}

f32
acos(f32 num) {
    return _acos_f32(num);
}

f32
sin(f32 num) {
    return _sin_f32(num);
}

f32
asin(f32 num) {
    return _asin_f32(num);
}

f32
tan(f32 num) {
    return _tan_f32(num);
}

f32
atan(f32 num) {
    return _atan_f32(num);
}

f32
sqrt(f32 num) {
    return _sqrt_f32(num);
}

f32
round(f32 num) {
    return _round_f32(num);
}

f32
floor(f32 num) {
    return _floor_f32(num);
}

f32
ceil(f32 num) {
    return _ceil_f32(num);
}

f32
abs(f32 num) {
    // TODO(Alexander): we can perhaps optimize this?
    return num < 0.0f ? -num : num;
}

s32
abs(s32 num) {
    // TODO(Alexander): we can perhaps optimize this?
    return num < 0 ? -num : num;
}

f32
random_f32() {
    return (f32) _random_s32() / (RAND_MAX + 1.0f);
}


inline umm
cstring_count(cstring str) {
    umm count = 0;
    u8* curr = (u8*) str;
    while (*curr) {
        count++;
        curr++;
    }
    return count;
}

struct Fixed_Array {
    void* data;
    smm count;
};

struct Dynamic_Array {
    void* data;
    smm count;
    smm capacity;
};

enum Type_Kind {
    Unresolved,
    Void,
    Any,
    Type,
    Basic,
    Array,
    Struct,
    Union,
    Enum,
    Function,
    Pointer,
};

enum Basic_Type_Info {
    Bool,
    S8,
    S16,
    S32,
    S64,
    U8,
    U16,
    U32,
    U64,
    F32,
    F64,
    String,
    CString
}

struct Type_Info {
    Type_Kind kind;
    
    union {
        Basic_Type_Info Basic;
        Struct_Type_Info Struct;
        Enum_Type_Info Enum;
        Array_Type_Info Array;
    };
}

struct Struct_Field_Info {
    Type_Info* type;
    string ident;
    s64 offset;
}

struct Struct_Type_Info {
    string ident;
    []Struct_Field_Info fields;
}

struct Enum_Type_Info {
    string ident;
    Type_Info* type;
    []string names;
}

struct Array_Type_Info {
    Type_Info* elem_type;
    smm elem_size;
    smm fixed_count; // -1 => if value stores the count
}

struct Var_Args {
    u8* data;
    []Type_Info* types;
}

inline Type_Info*
type_info(Type type) {
    return (Type_Info*) type;
}

internal void
print_newline_with_spaces(int count) {
    print("\n");
    for (int i = 0; i < count; i++) {
        print(" ");
    }
}

internal s64
data_to_s64(Basic_Type_Info info, void* data) {
    switch (info) {
        case Basic_Type_Info.S8: {
            return *((s8*) data);
        }
        
        case Basic_Type_Info.S16: {
            return *((s16*) data);
        }
        
        case Basic_Type_Info.S32: {
            return *((s32*) data);
        }
        
        case Basic_Type_Info.S64: {
            return *((s64*) data);
        }
    }
    
    return 0;
}

internal u64
data_to_u64(Basic_Type_Info info, void* data) {
    switch (info) {
        case Basic_Type_Info.U8: {
            return *((u8*) data);
        }
        
        case Basic_Type_Info.U16: {
            return *((u16*) data);
        }
        
        case Basic_Type_Info.U32: {
            return *((u32*) data);
        }
        
        case Basic_Type_Info.U64: {
            return *((u64*) data);
        }
    }
    
    return 0;
}

internal f64
data_to_f64(Basic_Type_Info info, void* data) {
    switch (info) {
        case Basic_Type_Info.F32: {
            return *((f32*) data);
        }
        
        case Basic_Type_Info.F64: {
            return *((f64*) data);
        }
    }
    
    return 0.0f;
}

internal void
print_unsigned_integer(u64 integer) {
    //debug_break();
    if (integer == 0) {
        _put_string("0");
        return;
    }
    
    [20]u8 result;
    int ptr = result.count;
    
    while (integer > 0) {
        u8 digit = (u8) (integer % 10);
        result[--ptr] = '0' + digit;
        integer /= 10;
    }
    
    string s;
    s.data = &result[ptr];
    s.count = result.count - ptr;
    _put_string(s);
}

internal void
print_signed_integer(s64 integer) {
    if (integer < 0) {
        integer = -integer;
        _put_string("-");
    }
    
    u64 unsigned_integer = (u64) integer;
    print_unsigned_integer(unsigned_integer);
}

internal void
print_floating_point(f64 floating_point) {
    // TODO(Alexander): this is not the best implementation, improve this later
    s64 whole_part = (s64) floating_point;
    print_signed_integer(whole_part);
    _put_string(".");
    
    f64 fractional_part = floating_point - (f64) whole_part;
    
    [6]u8 fractional_digits;
    
    for (int i = 0; i < fractional_digits.count; i++) {
        fractional_part *= 10.0f;
        u8 digit = (u8) fractional_part;
        fractional_digits[i] = '0' + digit;
        fractional_part -= (f64) digit;
    }
    
    string test;
    test.data = fractional_digits.data;
    test.count = fractional_digits.count;
    _put_string(test);
}

#define pln(format, ...) print(format##"\n", __VA_ARGS__)

void
print(string format, ...var_args) {
    int var_args_index = 0;
    u8* var_arg_data = var_args.data;
    
    string substring;
    substring.data = format.data;
    substring.count = 0;
    
    for (smm chr_index = 0; chr_index < format.count; chr_index++) {
        u8 chr = format.data[chr_index];
        
        if (chr == '%') {
            smm cnt = var_args.types.count;
            if (var_args_index < cnt) {
                _put_string(substring);
                substring.data = format.data + chr_index + 1;
                substring.count = 0;
                
                Type_Info* type_info = var_args.types[var_args_index];
                print_data_from_type_info(type_info, var_arg_data);
                var_args_index++;
                // NOTE(Alexander): if data doesn't fit in 8 bytes, store a pointer instead
                var_arg_data += 8;
            } else {
                substring.count++;
            }
        } else {
            substring.count++;
        }
    }
    
    _put_string(substring);
}

void
print_data_from_type_info(Type_Info* type, void* data, int indent=0) {
    switch (type.kind) {
        case Type_Kind.Basic: {
            switch (type.Basic) {
                case Basic_Type_Info.Bool: {
                    if (*((bool*) data)) {
                        print("true");
                    } else {
                        print("false");
                    }
                }
                
                case Basic_Type_Info.S8:
                case Basic_Type_Info.S16:
                case Basic_Type_Info.S32:
                case Basic_Type_Info.S64: {
                    s64 num = data_to_s64(type.Basic, data);
                    print_signed_integer(num);
                }
                
                case Basic_Type_Info.U8:
                case Basic_Type_Info.U16:
                case Basic_Type_Info.U32:
                case Basic_Type_Info.U64: {
                    u64 num = data_to_u64(type.Basic, data);
                    print_unsigned_integer(num);
                }
                
                case Basic_Type_Info.F32:
                case Basic_Type_Info.F64: {
                    f64 num = data_to_f64(type.Basic, data);
                    print_floating_point(num);
                }
                
                case Basic_Type_Info.String: {
                    // TODO(Alexander): denormalize var args
                    string s = **((string**) data);
                    _put_string(s);
                }
                
                case Basic_Type_Info.CString: {
                    cstring cstr = *((cstring*) data);
                    string s;
                    s.data = (u8*) cstr;
                    s.count = cstring_count(cstr);
                    _put_string(s);
                }
            }
        }
        
        case Type_Kind.Enum: {
            //debug_break();
            
            s64 value = 0;
            switch (type.Enum.type.kind) {
                case Basic_Type_Info.S8:
                case Basic_Type_Info.S16:
                case Basic_Type_Info.S32:
                case Basic_Type_Info.S64: {
                    value = data_to_s64(type.Enum.type.kind, data);
                }
                
                case Basic_Type_Info.U8:
                case Basic_Type_Info.U16:
                case Basic_Type_Info.U32:
                case Basic_Type_Info.U64: {
                    value = data_to_u64(type.Enum.type.kind, data);
                }
            }
            
            print("%.", type.Enum.ident);
            if (value >= 0 && value < type.Enum.names.count) {
                //debug_break();
                print("% (%)", type.Enum.names[value], value);
            } else {
                print("%", value);
            }
        }
        
        case Type_Kind.Array: {
            print("{ ");
            
            // TODO(Alexander): find a better way to deserialize arrays
            Fixed_Array arr;
            if (type.Array.fixed_count >= 0) {
                arr.data = *(void**) data;
                arr.count = type.Array.fixed_count;
            } else {
                arr = **(Fixed_Array**) data;
            }
            
            Type_Info* elem_type = type.Array.elem_type;
            
            const int max_elements_to_show = 5;
            
            for (int array_index = 0; 
                 array_index < arr.count && array_index < max_elements_to_show; 
                 array_index++) {
                
                if (elem_type.kind != Type_Kind.Basic) {
                    print_newline_with_spaces(indent + 4);
                }
                
                smm offset = type.Array.elem_size*array_index;
                
                print_data_from_type_info(elem_type, (u8*) arr.data + offset, indent + 4);
                if (array_index + 1 < arr.count) {
                    print(", ");
                }
            }
            
            if (arr.count >= max_elements_to_show) {
                if (elem_type.kind != Type_Kind.Basic) {
                    print_newline_with_spaces(indent + 4);
                }
                print("...+% more", arr.count - max_elements_to_show);
            }
            
            if (elem_type.kind != Type_Kind.Basic) {
                print_newline_with_spaces(indent);
                print("}");
            } else {
                print(" }");
            }
        }
        
        case Type_Kind.Union:
        case Type_Kind.Struct: {
            //print("% {", type.Struct.ident);
            indent += 4;
            for (int field_index = 0; field_index < type.Struct.fields.count; field_index++) {
                Struct_Field_Info field = type.Struct.fields[field_index];
                if (field.offset == 0 && type.kind == Type_Kind.Union && field_index > 0) {
                    break;
                }
                
                print_newline_with_spaces(indent);
                //print("%: ", field.ident);
                print_data_from_type_info(field.type,  (u8*) data + field.offset, indent);
                
                if (field_index + 1 < type.Struct.fields.count) {
                    //print(", ");
                }
            }
            indent -= 4;
            print_newline_with_spaces(indent);
            //print("}");
            
            if (indent == 0) {
                print("\n");
            }
        }
    }
}

#define print_var(var) \
print_data_from_type_info(type_of(var), &var);