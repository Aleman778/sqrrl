// Based on https://raytracing.github.io/books/RayTracingInOneWeekend.html

#define PI_F32 3.1415926535897932385f
#define INF_F32 100000000000000000000000000000000000.0f

f32
degrees_to_radians(f32 degrees) {
    return degrees * PI_F32 / 180.0f;
}

f32
random_f32_between(f32 minimum, f32 maximum) {
    assert(maximum >= minimum);
    return minimum + (maximum-minimum)*random_f32();
}

f32
clamp_f32(f32 v, f32 min, f32 max) {
    if (v < min) {
        v = min;
    } else if (v > max) {
        v = max;
    }
    return v;
}

#include "vecmath.sq"

//#define PRINT_AST 1
//#define PRINT_BYTECODE 1
//#define PRINT_ASM_VREG 1
//#define PRINT_ASM 1

v3
random_v3_in_unit_sphere() {
    while (true) {
        v3 v;
        v.x = random_f32();
        v.y = random_f32();
        v.z = random_f32();
        if (vec3_length_squared(v) >= 1.0f) {
            continue;
        }
        
        return v;
    }
}

v3
ray_sky_color(ray r) {
    v3 dir = r.direction;
    dir = vec3_normalize(dir);
    
    f32 t = 0.5f*(dir.y + 1.0f);
    f32 t_inv = 1.0f-t;
    
    //v3 sky_color_0 = vec3(0.98f, 0.61f, 0.51f);
    //v3 sky_color_1 = vec3(52.0f/255.0f, 94.0f/255.0f, 173.0f/255.0f);
    
    v3 sky_color_0 = vec3(1.0f, 1.0f, 1.0f);
    v3 sky_color_1 = vec3(0.5f, 0.7f, 1.0f);
    
    v3 color_0 = vec3_scale(sky_color_0, t_inv);
    v3 color_1 = vec3_scale(sky_color_1, t);
    v3 color = vec3_add(color_0, color_1);
    return color;
}

struct Hit_Result {
    v3 p;
    v3 normal;
    f32 t;
}

struct Sphere {
    v3 p;
    f32 radius;
}

Hit_Result
hit_sphere(Sphere sphere, ray r, f32 t_min, f32 t_max) {
    Hit_Result result;
    result.t = -1.0f;
    
    v3 oc = vec3_sub(r.origin, sphere.p);
    
    f32 a = vec3_length_squared(r.direction);
    f32 half_b = vec3_dot(oc, r.direction);
    f32 c = vec3_length_squared(oc) - sphere.radius*sphere.radius;
    f32 discriminant = half_b*half_b - a*c;
    
    if (discriminant < 0.0f) {
        return result;
    }
    
    f32 sqrt_discriminant = sqrt(discriminant);
    f32 root = (-half_b - sqrt_discriminant) / a;
    if (root < t_min || root >= t_max) {
        root = (-half_b + sqrt_discriminant) / a;
        if (root < t_min || root >= t_max) {
            return result;
        }
    }
    
    result.t = root;
    result.p = ray_at(r, root);
    result.normal = vec3_sub(result.p, sphere.p);
    result.normal = vec3_scale(result.normal, 1.0f/sphere.radius);
    return result;
}

v3
ray_color(ray r, [2]Sphere spheres, int depth) {
    //print_vec3(spheres[0].p);
    if (depth <= 0) {
        return vec3(0.0f, 0.0f, 0.0f);
    }
    
    f32 t_min = 0.001f;
    f32 t_max = INF_F32;
    
    Hit_Result found_hit;
    found_hit.t = 0.0f-1.0f;
    
    for (int i = 0; i < (int) spheres.count; i += 1) {
        Sphere s = spheres[i];
        //pln("sphere% - pos: %, %, % - radius: %", i, s.p.x, s.p.y, s.p.z, s.radius);
        Hit_Result hit = hit_sphere(s, r, t_min, t_max);
        if (hit.t > 0.0f) {
            t_max = hit.t;
            found_hit = hit;
        }
    }
    
    v3 color;
    if (found_hit.t > 0.0f) {
        ray r_bounce;
        r_bounce.origin = vec3_add(r.origin, vec3_scale(r.direction, found_hit.t));
        r_bounce.direction = vec3_add(found_hit.normal, random_v3_in_unit_sphere());
        
        depth -= 1;
        color = vec3_scale(ray_color(r_bounce, spheres, depth), 0.5f);
    } else {
        //color = vec3_add(color, ray_sky_color(r));
        color = ray_sky_color(r);
    }
    
    return color;
}


int
main() {
    //debug_break();
    
    f32 aspect_ratio = 16.0f / 9.0f;
    int image_width = 400;
    int image_height = (int) ((f32) image_width / aspect_ratio);
    int max_ray_depth = 50;
    
    //pln("resolution: % x %", image_width, image_height);
    
    f32 viewport_height = 2.0f;
    f32 viewport_width = aspect_ratio * viewport_height;
    
    v3 origin = vec3(0.0f, 0.0f, 0.0f);
    v3 horizontal = vec3(viewport_width, 0.0f, 0.0f);
    v3 vertical = vec3(0.0f, viewport_height, 0.0f);
    v3 focal = vec3(0.0f, 0.0f, 1.0f);
    
    // Compute the lower left screen coordinate
    v3 temp = vec3_scale(horizontal, 0.5f);
    v3 lower_left_corner = vec3_sub(origin, temp);
    temp = vec3_scale(vertical, 0.5f);
    lower_left_corner = vec3_sub(lower_left_corner, temp);
    lower_left_corner = vec3_sub(lower_left_corner, focal);
    
    pln("P3\n% %\n255", image_width, image_height);
    
    [2]Sphere spheres;
    spheres[0].p = vec3(0.0f, 0.0f, -1.0f);
    spheres[0].radius = 0.5f;
    
    spheres[1].p = vec3(0.0f, -100.5f, -1.0f);
    spheres[1].radius = 100.0f;
    
    int samples_per_pixel = 1;
    for (int y = image_height-1; y >= 0; y -= 1) {
        for (int x = 0; x < image_width; x += 1) {
            // TODO(Alexander): bug (image_width) breaks
            // TODO(Alexander): bug (image_width - 1) breaks
            //pln("%, %", y, x);
            
            v3 color = vec3(0.0f, 0.0f, 0.0f);
            for (int sample_index = 0;
                 sample_index < samples_per_pixel;
                 sample_index += 1) {
                f32 u = ((f32) x + random_f32()) / (f32) image_width;
                f32 v = ((f32) y + random_f32()) / (f32) image_height;
                
                temp = vec3_scale(horizontal, u);
                v3 dir = vec3_add(lower_left_corner, temp);
                temp = vec3_scale(vertical, v);
                dir = vec3_add(dir, temp);
                dir = vec3_sub(dir, origin);
                
                //print_vec3(dir);
                ray r;
                r.origin = origin;
                r.direction = dir;
                
                v3 c = ray_color(r, spheres, max_ray_depth);
                color = vec3_add(color, c);
            }
            
            
            f32 scale = 1.0f / (f32) samples_per_pixel;
            //color = vec3_scale(color, scale);
            
            // Divide the color by the number of samples and gamma-correct for gamma=2.0.
            color.x = sqrt(scale * color.x);
            color.y = sqrt(scale * color.y);
            color.z = sqrt(scale * color.z);
            
            // Write the color
            int ir = (int) (256.0f*clamp_f32(color.x, 0.0f, 0.999f));
            int ig = (int) (256.0f*clamp_f32(color.y, 0.0f, 0.999f));
            int ib = (int) (256.0f*clamp_f32(color.z, 0.0f, 0.999f));
            
            pln("% % %", ir, ig, ib);
            //return 0;
        }
    }
    
    return 0;
}
