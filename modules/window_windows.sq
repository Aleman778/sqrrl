
bool is_running = false;
HWND hwnd;
HDC hdc;


LRESULT CALLBACK
window_callback(HWND window, UINT message, WPARAM w_param, LPARAM l_param) {
    LRESULT result = 0;
    
    if (message == WM_CLOSE) {
        is_running = false;
    } else if (message == WM_DESTROY) {
        is_running = false;
    } else {
        result = DefWindowProcA(window, message, w_param, l_param);
    }
    
    return result;
}

void
show_error(string message) {
    int error_code = GetLastError();
    if (error_code) {
        message = string_print("% (Error code: %)", message, error_code);
    } else {
        message = string_print("%", message);
    }
    MessageBoxA(0, string_to_cstring(message), "Error", MB_OK);
    ExitProcess(error_code);
}


void
init_window(int width, int height, string title) {
    assert(!hwnd, "window is already initialized");
    
    HINSTANCE h_instance = GetModuleHandleA(0);
    
    WNDCLASSA wndclass = {};
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = &window_callback;
    wndclass.hInstance = h_instance;
    wndclass.lpszClassName = "windclass"; // TODO: does this need to be unique for multiple windows?
    
    if (RegisterClassA(&wndclass)) {
        hwnd = CreateWindowExA(0,
                               wndclass.lpszClassName,
                               string_to_cstring(title),
                               WS_OVERLAPPEDWINDOW | WS_VISIBLE,
                               CW_USEDEFAULT,
                               CW_USEDEFAULT,
                               width, height,
                               0, 0,
                               wndclass.hInstance,
                               0);
        
        if (hwnd) {
            hdc = GetDC(hwnd);
            if (create_opengl_context(hdc)) {
                is_running = true;
            }
        } else {
            show_error("Failed to create window");
        }
    } else {
        show_error("Failed to create window");
    }
}

bool
window_should_close() {
    MSG message;
    while (PeekMessageA(&message, 0, 0, 0, PM_REMOVE)) {
        TranslateMessage(&message);
        DispatchMessageA(&message);
    }
    
    return !is_running;
}

void
window_swap_buffers() {
    SwapBuffers(hdc);
}
