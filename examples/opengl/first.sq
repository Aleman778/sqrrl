#include <basic.sq>
#include <window.sq>
#include <stb_image.sq>

// TODO(Alexander): COMPILER BUG: opengl.sq has to be loaded last messes up the import directory table
#include <opengl.sq>


#define RED (v4) { 1.0f, 0.0f, 0.0f, 1.0f }
#define GREEN (v4) { 0.0f, 1.0f, 0.0f, 1.0f }
#define WHITE (v4) { 1.0f, 1.0f, 1.0f, 1.0f }


string
win32_read_entire_file(cstring filename) {
    string result;
    HANDLE file_handle = CreateFileA(filename, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);
    
    if (file_handle != INVALID_HANDLE_VALUE) {
        LARGE_INTEGER file_size;
        if (GetFileSizeEx(file_handle, &file_size)) {
            result.count = (u32) file_size.QuadPart;
            result.data = (u8*) VirtualAlloc(0, result.count, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
            
            if (result.data) {
                if (!ReadFile(file_handle, result.data, (u32) result.count, 0, 0)) {
                    // TODO(alexander): logging, failed read file
                }
                
            } else {
                // TODO(alexander): logging, failed to allocate memory
            }
            
        } else {
            // TODO(alexander): logging, failed to get file size
        }
        
        CloseHandle(file_handle);
    } else {
        // TODO(alexander): logging, file not found
    }
    
    return result;
}

void
win32_free_file_memory(void* memory) {
    VirtualFree(memory, 0, MEM_RELEASE);
}

int
compile_shader_from_file(int program, int shader_type, cstring filename) {
    int shader = glCreateShader(shader_type);
    string source = win32_read_entire_file(filename);
    cstring source_cstring = string_to_cstring(source);
    
    glShaderSource(shader, 1, cast(GLchar**) &source_cstring, 0);
    glCompileShader(shader);
    win32_free_file_memory(source.data);
    cstring_free(source_cstring);
    
    GLint success;
    glGetShaderiv(shader, GL_COMPILE_STATUS, &success);
    if (!success) {
        // TODO: COMPILER BUG: wasn't possible to just use a stack allocated array?!??!
        string message;
        message.data = (u8*) malloc(1024);
        message.count = 0;
        glGetShaderInfoLog(shader, 1024, cast(GLsizei*) &message.count, cast(GLchar*) message.data);
        pln("%: %", filename, message);
        free(message.data);
        return false;
    }
    
    glAttachShader(program, shader);
    return shader;
}

enum Render_Op {
    Draw_Triangles,
}

struct v2 {
    f32 x, y;
}

struct v3 {
    f32 x, y, z;
}

struct v4 {
    f32 r, g, b, a;
}

struct Vertex {
    v3 pos;
    v2 texcoord;
    v4 tint;
}

struct Render_Queue {
    
}

struct Render_Command {
    Render_Op op;
    
    union {
        Vertex* vertices;
        f32* data;
    };
    
    int vertex_count;
}

struct Push_Buffer {
    [65536]u8 base;
    u32 used;
}

// NOTE(Alexander): align has to be a power of two.
#define is_power_of_two(x) (((x) & ((x) - 1)) == 0)
#define assert_power_of_two(x) assert(is_power_of_two(x) && "x is not power of two")
inline umm
align_forward(umm address, umm align) {
    assert_power_of_two(align);
    umm modulo = address & (align - 1);
    if (modulo != 0) {
        address += align - modulo;
    }
    return address;
}

void*
push_size(Push_Buffer* buf, umm size, umm align) {
    umm base_offset = (umm) buf.base.data + (umm) buf.used;
    umm offset = align_forward(base_offset, align) - (umm) buf.base.data;
    assert((smm) (offset + size) <= buf.base.count);
    buf.used = (u32) (offset + size);
    
    void* result = buf.base.data + offset;
    memset(result, 0, size);
    return result;
}

#define push_struct(buf, T) (T*) push_size(buf, sizeof(T), alignof(T))

Render_Command*
push_command(Push_Buffer* buf, Render_Op op) {
    Render_Command* command = push_struct(buf, Render_Command);
    command.op = op;
    command.data = (f32*) push_size(buf, 1024, alignof(f32));
    return command;
}

struct OpenGL {
    GLuint vertex_array;
    GLuint vertex_buffer;
    GLuint index_buffer;
    GLuint texture;
    
    GLuint program;
    GLuint uniform_texture;
}

void
init_opengl(OpenGL* opengl) {
    // Vertex array
    glGenVertexArrays(1, &opengl.vertex_array);
    glBindVertexArray(opengl.vertex_array);
    
    // Setup buffers
    glGenBuffers(1, &opengl.vertex_buffer);
    
    // Setup textures
    glGenTextures(1, &opengl.texture);
    
}

void
opengl_begin_drawing(OpenGL* opengl, Push_Buffer* buf) {
    glClear(GL_COLOR_BUFFER_BIT);
    
    buf.used = 0;
}

void
opengl_end_drawing(OpenGL* opengl, Render_Command* command) {
    
    glBindVertexArray(opengl.vertex_array);
    glBindBuffer(GL_ARRAY_BUFFER, opengl.vertex_buffer);
    glBufferData(GL_ARRAY_BUFFER,
                 command.vertex_count*sizeof(Vertex), 
                 command.data, GL_DYNAMIC_DRAW);
    
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), 0);
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), 3 * sizeof(f32));
    glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), 5 * sizeof(f32));
    glEnableVertexAttribArray(0);
    glEnableVertexAttribArray(1);
    glEnableVertexAttribArray(2);
    
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, opengl.texture);
    
    glUseProgram(opengl.program);
    glUniform1i(opengl.uniform_texture, 0);
    
    glDrawArrays(GL_TRIANGLES, 0, command.vertex_count);
}

void
push_rectangle(Render_Command* command, f32 x, f32 y, f32 width, f32 height, v4 tint) {
    Vertex* tl = &command.vertices[command.vertex_count++];
    Vertex* tr = &command.vertices[command.vertex_count++];
    Vertex* bl = &command.vertices[command.vertex_count++];
    Vertex* tr2 = &command.vertices[command.vertex_count++];
    Vertex* br = &command.vertices[command.vertex_count++];
    Vertex* bl2 = &command.vertices[command.vertex_count++];
    tl.pos  = { x, y };                  tl.texcoord  = { 0.0f, 0.0f }; tl.tint  = tint;
    tr.pos  = { x + width, y };          tr.texcoord  = { 1.0f, 0.0f }; tr.tint  = tint;
    tr2.pos = { x + width, y };          tr2.texcoord = { 1.0f, 0.0f }; tr2.tint = tint;
    bl.pos  = { x, y + height };         bl.texcoord  = { 0.0f, 1.0f }; bl.tint  = tint;
    bl2.pos = { x, y + height };         bl2.texcoord = { 0.0f, 1.0f }; bl2.tint = tint;
    br.pos  = { x + width, y + height }; br.texcoord  = { 1.0f, 1.0f }; br.tint  = tint;
}

struct Loaded_Image {
    int width;
    int height;
    int num_components;
    int stride; 
    u8* data;
}

Loaded_Image
load_image(string filename) {
    Loaded_Image result;
    cstring cfilename = string_to_cstring(filename);
    u8* data = stbi_load(cfilename, &result.width, &result.height, &result.num_components, 0);
    cstring_free(cfilename);
    
    if (!data) {
        pln("Failed to load image `%`", filename);
    }
    
    result.data = data;
    result.stride = result.width * result.num_components;
    return result;
}

int
main() {
    
    f32 aspect_ratio = 16.0f / 9.0f;
    int height = 720;
    int width = (int) ((f32) height * aspect_ratio);
    
    init_window(width, height, "OpenGL Test");
    
    Push_Buffer* push_buffer = (Push_Buffer*) calloc(1, sizeof(Push_Buffer)); // 64k
    
    OpenGL* opengl = (OpenGL*) calloc(1, sizeof(OpenGL));
    init_opengl(opengl);
    
    Loaded_Image image = load_image("../examples/opengl/resurrect-64-1x.png");
    // TODO: add support for freeing the image!
    
    GLenum internal_format = (image.num_components == 3) ? GL_RGB : GL_RGBA;
    glBindTexture(GL_TEXTURE_2D, opengl.texture);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    
    glTexImage2D(GL_TEXTURE_2D, 0, internal_format, image.width, image.height, 0,
                 GL_RGB, GL_UNSIGNED_BYTE, image.data); // TODO: do we want ALPHA component in the format
    
    
    
    //[]f32 triangles = {
    //1.0f, -1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f,
    //-1.0f,  1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f,
    //-1.0f, -1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f,
    
    //-1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f,
    //1.0f,  1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f,
    //1.0f, -1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f,
    //};
    
    
    
    //command.vertices. = triangles.data;
    //push_rectangle(&command, -1.0f, -1.0f, 2.0f, 2.0f, red);
    //pln("%", command);
    
    
    // Setup shaders
    opengl.program = glCreateProgram();
    int vs = compile_shader_from_file(opengl.program, GL_VERTEX_SHADER, "../examples/opengl/test.vs");
    int fs = compile_shader_from_file(opengl.program, GL_FRAGMENT_SHADER, "../examples/opengl/test.fs");
    if (vs && fs) {
        int success;
        glLinkProgram(opengl.program);
        glDeleteShader(vs);
        glDeleteShader(fs);
        
        glGetProgramiv(opengl.program, GL_LINK_STATUS, &success);
        if (!success) {
            string message;
            message.data = (u8*) malloc(1024);
            message.count = 0;
            glGetProgramInfoLog(opengl.program, 1024, cast(GLsizei*) &message.count, cast(GLchar*) message.data);
            pln("%", message);
            free(message.data);
            return false;
        }
    }
    opengl.uniform_texture = glGetUniformLocation(opengl.program, (GLchar*) string_to_cstring("u_texture"));
    
    while (!window_should_close()) {
        opengl_begin_drawing(opengl, push_buffer);
        
        Render_Command* command = push_command(push_buffer, Render_Op.Draw_Triangles);
        push_rectangle(command, -0.2f, -0.2f, 0.4f, 0.4f, WHITE);
        //push_rectangle(command, -0.4f, -0.2f, 0.4f, 0.4f, GREEN);
        
        glClearColor(0.0f, 0.5f, 1.0f, 1.0f);
        
        opengl_end_drawing(opengl, command);
        
        window_swap_buffers();
    }
    
    ExitProcess(0);
}
